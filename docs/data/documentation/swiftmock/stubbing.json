{"metadata":{"roleHeading":"Article","title":"Stubbing","modules":[{"name":"SwiftMock"}],"role":"article"},"schemaVersion":{"patch":0,"major":0,"minor":3},"sections":[],"seeAlsoSections":[{"identifiers":["doc:\/\/SwiftMock\/documentation\/SwiftMock\/Introduction","doc:\/\/SwiftMock\/documentation\/SwiftMock\/Argument-Matchers","doc:\/\/SwiftMock\/documentation\/SwiftMock\/Verifying"],"generated":true,"title":"Usage"}],"variants":[{"paths":["\/documentation\/swiftmock\/stubbing"],"traits":[{"interfaceLanguage":"swift"}]}],"abstract":[{"type":"text","text":"This article describes in detail the available possibilities of the stubbing method."}],"primaryContentSections":[{"kind":"content","content":[{"level":2,"text":"Overview","anchor":"Overview","type":"heading"},{"inlineContent":[{"type":"text","text":"When we work with mocks we want to have some flexibility in our capabilities. Let’s look at the package’s capabilities."}],"type":"paragraph"},{"level":3,"text":"Calling Methods Sequentially","anchor":"Calling-Methods-Sequentially","type":"heading"},{"inlineContent":[{"type":"text","text":"In some flows, the methods of our mocks may be called several times and we do not always want to receive the same return value. To do this, we can use the builder’s call chain."}],"type":"paragraph"},{"code":["@Mock","public protocol AlbumService {","\tfunc getAlbumName() async throws -> String","}","","func test() {","\tlet mock = AlbumServiceMock()","\t","\twhen(mock.$getAlbumName())","\t\t.thenReturn(\"#4\")","\t\t.thenReturn(\"Inspiration Is Dead\")","\t\t.thenReturn(\"Just a Moment\")","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"In this case, the first time we call the ","type":"text"},{"type":"codeVoice","code":"getAlbumName()"},{"text":" method, we will get the value ","type":"text"},{"code":"\"#4\"","type":"codeVoice"},{"type":"text","text":", the second time we will get the value "},{"code":"\"Inspiration Is Dead\"","type":"codeVoice"},{"text":", and all subsequent times we will get the value ","type":"text"},{"code":"\"Just a Moment\"","type":"codeVoice"},{"text":".","type":"text"}]},{"text":"Dealing with errors","type":"heading","level":3,"anchor":"Dealing-with-errors"},{"inlineContent":[{"text":"Sometimes we want to test not only the success path of our code, but also those moments when one of our services threw us some error at a certain moment. The ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/ThrowsMethodInvocationBuilder\/thenThrow(_:)"},{"type":"text","text":" method is used for this. Please note that this method is present in the builder only if the method we want to stub is marked as "},{"type":"codeVoice","code":"throws"},{"text":".","type":"text"}],"type":"paragraph"},{"code":["@Mock","public protocol AlbumService {","\tfunc getAlbumName() async throws -> String","}","","public enum AlbumServiceError: Error {","\tcase endOfDiscography","}","","func test() {","\tlet mock = AlbumServiceMock()","","\twhen(mock.$getAlbumName())","\t\t.thenReturn(\"#4\")","\t\t.thenReturn(\"Inspiration Is Dead\")","\t\t.thenThrow(AlbumServiceError.endOfDiscography)","\t\t.thenReturn(\"#4\")","}"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"In this case, after retrieving the first two albums of the group when calling the ","type":"text"},{"type":"codeVoice","code":"getAlbumName()"},{"text":" method, the method will throw an ","type":"text"},{"type":"codeVoice","code":"endOfDiscography"},{"type":"text","text":" error."}]},{"inlineContent":[{"text":"In addition to this, we can see that we can combine ","type":"text"},{"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/ThrowsMethodInvocationBuilder\/thenReturn(_:)-23hjy","isActive":true,"type":"reference"},{"text":" and ","type":"text"},{"type":"reference","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/ThrowsMethodInvocationBuilder\/thenThrow(_:)","isActive":true},{"text":" in any order we need.","type":"text"}],"type":"paragraph"},{"anchor":"Argument-Matchers","text":"Argument Matchers","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default, a method stubbing accepts any arguments and does not check them in any way. To describe method stubbing for specific arguments, we can use the "},{"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/eq(_:)","type":"reference","isActive":true},{"text":" function.","type":"text"}]},{"code":["@Mock","public protocol AlbumService {","\tfunc getAlbum(id: UUID, group: String) async throws -> Album","}","","public enum AlbumServiceError: Error {","\tcase notFound","}","","func test() async throws {","\tlet uuid = UUID()","\tlet expected = Album(","\t\tuuid: uuid,","\t\tname: \"Last Aurorally\",","\t\tgroup: \"Ling Toshite Shigure\"","\t)","","\tlet mock = AlbumServiceMock()","","\twhen(mock.$getAlbum(id: eq(uuid)))","\t\t.thenReturn(album)","","\tlet actual = try await mock.getAlbum(","\t\tid: uuid, ","\t\tgroup: \"Ling Toshite Shigure\"","\t)","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"You can omit any arguments you don’t want to check. In this case, matcher "},{"type":"reference","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/any()","isActive":true},{"text":" will be used for this argument.","type":"text"}],"type":"paragraph"},{"anchor":"Stubbing-order","type":"heading","level":3,"text":"Stubbing order"},{"inlineContent":[{"text":"The order of stubbing plays an important role in choosing what data the system will use. The system looks for the last matching registered stubbing in order to return a value. In this regard, it is recommended to always first describe more general stubbings, using ","type":"text"},{"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/any()","isActive":true,"type":"reference"},{"type":"text","text":" for example, and then more specific ones."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["@Mock","public protocol AlbumService {","\tfunc getAlbum(id: UUID) async throws -> Album","}","","public enum AlbumServiceError: Error {","\tcase notFound","}","","func test() async throws {","\tlet uuid = UUID()","\tlet expected = Album(","\t\tuuid: uuid,","\t\tname: \"Last Aurorally\",","\t\tgroup: \"Ling Toshite Shigure\"","\t)","","\tlet mock = AlbumServiceMock()","","\twhen(mock.$getAlbum())","\t\t.thenThrow(AlbumServiceError.notFound)","\twhen(mock.$getAlbum(id: eq(uuid)))","\t\t.thenReturn(album)","","\tlet actual = try await mock.getAlbum(","\t\tid: uuid","\t)","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we swap the stubbing of the "},{"type":"codeVoice","code":"getAlbum()"},{"type":"text","text":" method in this example, we will always get an error, since our specific "},{"code":"uuid","type":"codeVoice"},{"type":"text","text":" matches the "},{"isActive":true,"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/any()","type":"reference"},{"type":"text","text":" matcher check."}]},{"type":"heading","text":"Override Stubbing","level":3,"anchor":"Override-Stubbing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we sequentially define two stubbings with the same argument matchers, then the second stubbing will override the first. This means that we will never get the same values or errors that we described in the first one."}]},{"type":"paragraph","inlineContent":[{"text":"If you really need such functionality, then your code most likely has a smell, but such a possibility still exists.","type":"text"}]},{"syntax":"swift","code":["@Mock","public protocol AlbumService {","\tfunc getAlbum(id: UUID) async throws -> Album","}","","public enum AlbumServiceError: Error {","\tcase notFound","}","","func test() async throws {","\tlet uuid = UUID()","\tlet expected = Album(","\t\tuuid: uuid,","\t\tname: \"I'mperfect\",","\t\tgroup: \"Ling Toshite Shigure\"","\t)","","\tlet mock = AlbumServiceMock()","","\twhen(mock.$getAlbum())","\t\t.thenThrow(AlbumServiceError.notFound)","","\tlet album = try await mock.getAlbum(uuid: UUID()) \/\/ Throw a error.","","\twhen(mock.$getAlbum())","\t\t.thenReturn(expected)","","\t\/\/ All calls of getAlbum() will return \"I'mperfect\" album.","}"],"type":"codeListing"}]}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/Stubbing"},"kind":"article","hierarchy":{"paths":[["doc:\/\/SwiftMock\/documentation\/SwiftMock"]]},"references":{"doc://SwiftMock/documentation/SwiftMock":{"title":"SwiftMock","abstract":[{"type":"text","text":"A package to simplify writing tests by automating the process of creating mock objects."}],"url":"\/documentation\/swiftmock","type":"topic","kind":"symbol","role":"collection","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock"},"doc://SwiftMock/documentation/SwiftMock/Introduction":{"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/Introduction","title":"Introduction","abstract":[{"type":"text","text":"First steps in protocol mocking."}],"url":"\/documentation\/swiftmock\/introduction","kind":"article","role":"article","type":"topic"},"doc://SwiftMock/documentation/SwiftMock/any()":{"url":"\/documentation\/swiftmock\/any()","type":"topic","kind":"symbol","title":"any()","role":"symbol","abstract":[{"type":"text","text":"Any possible value is suitable."}],"fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"any","kind":"identifier"},{"kind":"text","text":"<"},{"text":"Arguments","kind":"genericParameter"},{"kind":"text","text":">() -> "},{"preciseIdentifier":"s:9SwiftMock15ArgumentMatchera","kind":"typeIdentifier","text":"ArgumentMatcher"},{"text":"<","kind":"text"},{"text":"Arguments","kind":"typeIdentifier"},{"kind":"text","text":">"}],"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/any()"},"doc://SwiftMock/documentation/SwiftMock/ThrowsMethodInvocationBuilder/thenThrow(_:)":{"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/ThrowsMethodInvocationBuilder\/thenThrow(_:)","kind":"symbol","title":"thenThrow(_:)","type":"topic","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"text":"thenThrow","kind":"identifier"},{"text":"(","kind":"text"},{"text":"Error","kind":"typeIdentifier","preciseIdentifier":"s:s5ErrorP"},{"kind":"text","text":") -> "},{"text":"Self","kind":"typeIdentifier"}],"url":"\/documentation\/swiftmock\/throwsmethodinvocationbuilder\/thenthrow(_:)","abstract":[]},"doc://SwiftMock/documentation/SwiftMock/Argument-Matchers":{"abstract":[{"type":"text","text":"This article talks about how Argument Matcher works."}],"kind":"article","title":"Argument Matchers","url":"\/documentation\/swiftmock\/argument-matchers","type":"topic","role":"article","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/Argument-Matchers"},"doc://SwiftMock/documentation/SwiftMock/eq(_:)":{"fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"kind":"identifier","text":"eq"},{"text":"<","kind":"text"},{"text":"Arguments","kind":"genericParameter"},{"kind":"text","text":">("},{"kind":"typeIdentifier","text":"Arguments"},{"text":") -> ","kind":"text"},{"preciseIdentifier":"s:9SwiftMock15ArgumentMatchera","text":"ArgumentMatcher","kind":"typeIdentifier"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"Arguments"},{"text":">","kind":"text"}],"url":"\/documentation\/swiftmock\/eq(_:)","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/eq(_:)","abstract":[{"text":"Tests that the argument is equal to the given value.","type":"text"}],"kind":"symbol","title":"eq(_:)","type":"topic","role":"symbol"},"doc://SwiftMock/documentation/SwiftMock/Verifying":{"role":"article","title":"Verifying","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/Verifying","url":"\/documentation\/swiftmock\/verifying","abstract":[{"type":"text","text":"This article describes in detail the available possibilities of the "},{"type":"reference","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/verify(_:times:)","isActive":true},{"type":"text","text":" method."}],"kind":"article","type":"topic"},"doc://SwiftMock/documentation/SwiftMock/ThrowsMethodInvocationBuilder/thenReturn(_:)-23hjy":{"type":"topic","abstract":[],"role":"symbol","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/ThrowsMethodInvocationBuilder\/thenReturn(_:)-23hjy","kind":"symbol","title":"thenReturn(_:)","url":"\/documentation\/swiftmock\/throwsmethodinvocationbuilder\/thenreturn(_:)-23hjy","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"thenReturn"},{"text":"(","kind":"text"},{"text":"Result","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Self"}]},"doc://SwiftMock/documentation/SwiftMock/verify(_:times:)":{"url":"\/documentation\/swiftmock\/verify(_:times:)","kind":"symbol","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/verify(_:times:)","abstract":[],"role":"symbol","fragments":[{"text":"func","kind":"keyword"},{"kind":"text","text":" "},{"text":"verify","kind":"identifier"},{"text":"<","kind":"text"},{"kind":"genericParameter","text":"Mock"},{"text":">(","kind":"text"},{"text":"Mock","kind":"typeIdentifier"},{"kind":"text","text":", "},{"text":"times","kind":"externalParam"},{"kind":"text","text":": "},{"preciseIdentifier":"s:9SwiftMock12TimesMatchera","kind":"typeIdentifier","text":"TimesMatcher"},{"text":") -> ","kind":"text"},{"text":"Mock","kind":"typeIdentifier"},{"kind":"text","text":"."},{"text":"Verify","kind":"typeIdentifier"}],"title":"verify(_:times:)","type":"topic"}}}