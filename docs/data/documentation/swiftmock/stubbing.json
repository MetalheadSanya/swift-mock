{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/Stubbing"},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/swiftmock\/stubbing"]}],"metadata":{"roleHeading":"Article","role":"article","title":"Stubbing","modules":[{"name":"SwiftMock"}]},"sections":[],"primaryContentSections":[{"kind":"content","content":[{"level":2,"type":"heading","text":"Overview","anchor":"Overview"},{"inlineContent":[{"text":"When we work with mocks we want to have some flexibility in our capabilities. Let’s look at the package’s capabilities.","type":"text"}],"type":"paragraph"},{"anchor":"Property-Mocking","text":"Property Mocking","level":3,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Sometimes our services have not only methods, but also properties. For each property declared in the protocol, methods are generated for property stubbing. If a property is declared as read-only, then one stubbing method is generated in the form "},{"code":"$propertyNameGetter","type":"codeVoice"},{"text":", where ","type":"text"},{"code":"propertyName","type":"codeVoice"},{"type":"text","text":" is the name of the property. Stubbing using this method is similar to stubbing methods."}]},{"syntax":"swift","code":["@Mock","public protocol SomeService {","\tvar property: Int { get }","}","","func test() {","\tlet mock = SomeServiceMock()","","\twhen(mock.$propertyGetter())","\t\t.thenReturn(15)","\t","\tXCTAssertEqual(15, mock.property)","}"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a property is declared mutable, then in addition to getter stubbing, an additional method is generated for setter stubbing. This method is named "},{"code":"$propertyNameSetter","type":"codeVoice"},{"text":" and has a signature similar to a stubbing method with one argument and no return value. If your code is going to change this property, you MUST stub the property’s setter.","type":"text"}]},{"syntax":"swift","code":["@Mock","public protocol SomeService {","\tvar property: Int { get set }","}","","func test() {","\tlet mock = SomeServiceMock()","","\twhen(mock.$propertySetter())","\t\t.thenReturn()","","\tmock.property = 15","}"],"type":"codeListing"},{"inlineContent":[{"text":"Similar to method stubbing, you can define different stubbing for assignment different values","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["@Mock","public protocol SomeService {","\tvar property: Int { get set }","}","","func test() {","\tlet mock = SomeServiceMock()","","\twhen(mock.$propertySetter())","\t\t.thenReturn { _ in print(\"Some value was set\") }","\twhen(mock.$propertySetter(eq(15)))","\t\t.thenReturn { _ in print(\"Value 15 was set\") }","","\t\/\/ Prints: Value 15 was set","\tmock.property = 15","}"],"syntax":"swift"},{"level":3,"anchor":"Calling-Methods-Sequentially","text":"Calling Methods Sequentially","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In some flows, the methods of our mocks may be called several times and we do not always want to receive the same return value. To do this, we can use the builder’s call chain."}]},{"code":["@Mock","public protocol AlbumService {","\tfunc getAlbumName() async throws -> String","}","","func test() {","\tlet mock = AlbumServiceMock()","\t","\twhen(mock.$getAlbumName())","\t\t.thenReturn(\"#4\")","\t\t.thenReturn(\"Inspiration Is Dead\")","\t\t.thenReturn(\"Just a Moment\")","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"In this case, the first time we call the ","type":"text"},{"type":"codeVoice","code":"getAlbumName()"},{"text":" method, we will get the value ","type":"text"},{"code":"\"#4\"","type":"codeVoice"},{"type":"text","text":", the second time we will get the value "},{"type":"codeVoice","code":"\"Inspiration Is Dead\""},{"type":"text","text":", and all subsequent times we will get the value "},{"code":"\"Just a Moment\"","type":"codeVoice"},{"type":"text","text":"."}],"type":"paragraph"},{"text":"Dealing with errors","type":"heading","level":3,"anchor":"Dealing-with-errors"},{"inlineContent":[{"type":"text","text":"Sometimes we want to test not only the success path of our code, but also those moments when one of our services threw us some error at a certain moment. The "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/ThrowsMethodInvocationBuilder\/thenThrow(_:)"},{"text":" method is used for this. Please note that this method is present in the builder only if the method we want to stub is marked as ","type":"text"},{"code":"throws","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"type":"codeListing","code":["@Mock","public protocol AlbumService {","\tfunc getAlbumName() async throws -> String","}","","public enum AlbumServiceError: Error {","\tcase endOfDiscography","}","","func test() {","\tlet mock = AlbumServiceMock()","","\twhen(mock.$getAlbumName())","\t\t.thenReturn(\"#4\")","\t\t.thenReturn(\"Inspiration Is Dead\")","\t\t.thenThrow(AlbumServiceError.endOfDiscography)","\t\t.thenReturn(\"#4\")","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case, after retrieving the first two albums of the group when calling the "},{"type":"codeVoice","code":"getAlbumName()"},{"type":"text","text":" method, the method will throw an "},{"code":"endOfDiscography","type":"codeVoice"},{"type":"text","text":" error."}]},{"inlineContent":[{"text":"In addition to this, we can see that we can combine ","type":"text"},{"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/ThrowsMethodInvocationBuilder\/thenReturn(_:)-23hjy","type":"reference","isActive":true},{"text":" and ","type":"text"},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/ThrowsMethodInvocationBuilder\/thenThrow(_:)"},{"text":" in any order we need.","type":"text"}],"type":"paragraph"},{"text":"Argument Matchers","level":3,"anchor":"Argument-Matchers","type":"heading"},{"inlineContent":[{"type":"text","text":"By default, a method stubbing accepts any arguments and does not check them in any way. To describe method stubbing for specific arguments, we can use the "},{"isActive":true,"type":"reference","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/eq(_:)"},{"type":"text","text":" function."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["@Mock","public protocol AlbumService {","\tfunc getAlbum(id: UUID, group: String) async throws -> Album","}","","public enum AlbumServiceError: Error {","\tcase notFound","}","","func test() async throws {","\tlet uuid = UUID()","\tlet expected = Album(","\t\tuuid: uuid,","\t\tname: \"Last Aurorally\",","\t\tgroup: \"Ling Toshite Shigure\"","\t)","","\tlet mock = AlbumServiceMock()","","\twhen(mock.$getAlbum(id: eq(uuid)))","\t\t.thenReturn(album)","","\tlet actual = try await mock.getAlbum(","\t\tid: uuid, ","\t\tgroup: \"Ling Toshite Shigure\"","\t)","}"]},{"type":"paragraph","inlineContent":[{"text":"You can omit any arguments you don’t want to check. In this case, matcher ","type":"text"},{"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/any()","isActive":true,"type":"reference"},{"type":"text","text":" will be used for this argument."}]},{"text":"Stubbing order","level":3,"anchor":"Stubbing-order","type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The order of stubbing plays an important role in choosing what data the system will use. The system looks for the last matching registered stubbing in order to return a value. In this regard, it is recommended to always first describe more general stubbings, using "},{"type":"reference","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/any()","isActive":true},{"type":"text","text":" for example, and then more specific ones."}]},{"type":"codeListing","code":["@Mock","public protocol AlbumService {","\tfunc getAlbum(id: UUID) async throws -> Album","}","","public enum AlbumServiceError: Error {","\tcase notFound","}","","func test() async throws {","\tlet uuid = UUID()","\tlet expected = Album(","\t\tuuid: uuid,","\t\tname: \"Last Aurorally\",","\t\tgroup: \"Ling Toshite Shigure\"","\t)","","\tlet mock = AlbumServiceMock()","","\twhen(mock.$getAlbum())","\t\t.thenThrow(AlbumServiceError.notFound)","\twhen(mock.$getAlbum(id: eq(uuid)))","\t\t.thenReturn(album)","","\tlet actual = try await mock.getAlbum(","\t\tid: uuid","\t)","}"],"syntax":"swift"},{"inlineContent":[{"text":"If we swap the stubbing of the ","type":"text"},{"code":"getAlbum()","type":"codeVoice"},{"type":"text","text":" method in this example, we will always get an error, since our specific "},{"code":"uuid","type":"codeVoice"},{"text":" matches the ","type":"text"},{"type":"reference","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/any()","isActive":true},{"type":"text","text":" matcher check."}],"type":"paragraph"},{"level":3,"text":"Override Stubbing","type":"heading","anchor":"Override-Stubbing"},{"inlineContent":[{"type":"text","text":"If we sequentially define two stubbings with the same argument matchers, then the second stubbing will override the first. This means that we will never get the same values or errors that we described in the first one."}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you really need such functionality, then your code most likely has a smell, but such a possibility still exists."}]},{"type":"codeListing","syntax":"swift","code":["@Mock","public protocol AlbumService {","\tfunc getAlbum(id: UUID) async throws -> Album","}","","public enum AlbumServiceError: Error {","\tcase notFound","}","","func test() async throws {","\tlet uuid = UUID()","\tlet expected = Album(","\t\tuuid: uuid,","\t\tname: \"I'mperfect\",","\t\tgroup: \"Ling Toshite Shigure\"","\t)","","\tlet mock = AlbumServiceMock()","","\twhen(mock.$getAlbum())","\t\t.thenThrow(AlbumServiceError.notFound)","","\tlet album = try await mock.getAlbum(uuid: UUID()) \/\/ Throw a error.","","\twhen(mock.$getAlbum())","\t\t.thenReturn(expected)","","\t\/\/ All calls of getAlbum() will return \"I'mperfect\" album.","}"]}]}],"kind":"article","abstract":[{"type":"text","text":"This article describes in detail the available possibilities of the stubbing method."}],"seeAlsoSections":[{"generated":true,"title":"Usage","identifiers":["doc:\/\/SwiftMock\/documentation\/SwiftMock\/Introduction","doc:\/\/SwiftMock\/documentation\/SwiftMock\/Argument-Matchers","doc:\/\/SwiftMock\/documentation\/SwiftMock\/Verifying"]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"hierarchy":{"paths":[["doc:\/\/SwiftMock\/documentation\/SwiftMock"]]},"references":{"doc://SwiftMock/documentation/SwiftMock/eq(_:)":{"kind":"symbol","type":"topic","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"eq"},{"kind":"text","text":"<"},{"text":"Arguments","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"Arguments","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"text":"ArgumentMatcher","kind":"typeIdentifier","preciseIdentifier":"s:9SwiftMock15ArgumentMatchera"},{"kind":"text","text":"<"},{"text":"Arguments","kind":"typeIdentifier"},{"text":">","kind":"text"}],"url":"\/documentation\/swiftmock\/eq(_:)","role":"symbol","title":"eq(_:)","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/eq(_:)","abstract":[{"text":"Tests that the argument is equal to the given value.","type":"text"}]},"doc://SwiftMock/documentation/SwiftMock/ThrowsMethodInvocationBuilder/thenReturn(_:)-23hjy":{"title":"thenReturn(_:)","kind":"symbol","url":"\/documentation\/swiftmock\/throwsmethodinvocationbuilder\/thenreturn(_:)-23hjy","type":"topic","abstract":[],"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/ThrowsMethodInvocationBuilder\/thenReturn(_:)-23hjy","role":"symbol","fragments":[{"kind":"keyword","text":"func"},{"kind":"text","text":" "},{"kind":"identifier","text":"thenReturn"},{"text":"(","kind":"text"},{"text":"Result","kind":"typeIdentifier"},{"text":") -> ","kind":"text"},{"text":"Self","kind":"typeIdentifier"}]},"doc://SwiftMock/documentation/SwiftMock/Verifying":{"title":"Verifying","url":"\/documentation\/swiftmock\/verifying","role":"article","kind":"article","abstract":[{"type":"text","text":"This article describes in detail the available possibilities of the "},{"type":"reference","isActive":true,"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/verify(_:times:)"},{"type":"text","text":" method."}],"type":"topic","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/Verifying"},"doc://SwiftMock/documentation/SwiftMock":{"kind":"symbol","role":"collection","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock","type":"topic","abstract":[{"text":"A package to simplify writing tests by automating the process of creating mock objects.","type":"text"}],"title":"SwiftMock","url":"\/documentation\/swiftmock"},"doc://SwiftMock/documentation/SwiftMock/ThrowsMethodInvocationBuilder/thenThrow(_:)":{"role":"symbol","title":"thenThrow(_:)","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/ThrowsMethodInvocationBuilder\/thenThrow(_:)","url":"\/documentation\/swiftmock\/throwsmethodinvocationbuilder\/thenthrow(_:)","fragments":[{"kind":"keyword","text":"func"},{"text":" ","kind":"text"},{"kind":"identifier","text":"thenThrow"},{"text":"(","kind":"text"},{"text":"Error","kind":"typeIdentifier","preciseIdentifier":"s:s5ErrorP"},{"text":") -> ","kind":"text"},{"text":"Self","kind":"typeIdentifier"}],"abstract":[],"type":"topic","kind":"symbol"},"doc://SwiftMock/documentation/SwiftMock/Argument-Matchers":{"identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/Argument-Matchers","kind":"article","abstract":[{"type":"text","text":"This article talks about how Argument Matcher works."}],"role":"article","url":"\/documentation\/swiftmock\/argument-matchers","type":"topic","title":"Argument Matchers"},"doc://SwiftMock/documentation/SwiftMock/Introduction":{"type":"topic","title":"Introduction","role":"article","url":"\/documentation\/swiftmock\/introduction","kind":"article","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/Introduction","abstract":[{"type":"text","text":"First steps in protocol mocking."}]},"doc://SwiftMock/documentation/SwiftMock/any()":{"kind":"symbol","type":"topic","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/any()","title":"any()","url":"\/documentation\/swiftmock\/any()","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"kind":"identifier","text":"any"},{"kind":"text","text":"<"},{"text":"Arguments","kind":"genericParameter"},{"kind":"text","text":">() -> "},{"text":"ArgumentMatcher","kind":"typeIdentifier","preciseIdentifier":"s:9SwiftMock15ArgumentMatchera"},{"text":"<","kind":"text"},{"kind":"typeIdentifier","text":"Arguments"},{"kind":"text","text":">"}],"role":"symbol","abstract":[{"type":"text","text":"Any possible value is suitable."}]},"doc://SwiftMock/documentation/SwiftMock/verify(_:times:)":{"type":"topic","title":"verify(_:times:)","role":"symbol","url":"\/documentation\/swiftmock\/verify(_:times:)","identifier":"doc:\/\/SwiftMock\/documentation\/SwiftMock\/verify(_:times:)","kind":"symbol","fragments":[{"text":"func","kind":"keyword"},{"text":" ","kind":"text"},{"text":"verify","kind":"identifier"},{"text":"<","kind":"text"},{"text":"Mock","kind":"genericParameter"},{"text":">(","kind":"text"},{"text":"Mock","kind":"typeIdentifier"},{"text":", ","kind":"text"},{"text":"times","kind":"externalParam"},{"text":": ","kind":"text"},{"text":"TimesMatcher","preciseIdentifier":"s:9SwiftMock12TimesMatchera","kind":"typeIdentifier"},{"kind":"text","text":") -> "},{"kind":"typeIdentifier","text":"Mock"},{"kind":"text","text":"."},{"kind":"typeIdentifier","text":"Verify"}],"abstract":[]}}}